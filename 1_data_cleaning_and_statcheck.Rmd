---
title: "1: Data cleaning and statcheck"
author: "Lu Zhang"
date: "30/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setting up
## Loading packages
```{r, echo=FALSE}
# library packages
library(lme4)
library(lmerTest)
library(readr)
library(sjstats)
library(ggplot2)
library(dplyr)
library(plotly)
library(plyr)
library(statcheck)
library(tidyverse)
library(data.table)
```

# Data import and cleaning
Need to read in the data (1_unclean_categorised.csv) and then exclude p values reported with n.s
```{r}
# Read in data
categorised_data_final <- read.csv("1_unclean_categorised.csv")

# First convert all NS reported to lowercase
categorised_data_final$p <- tolower(categorised_data_final$p)

# Exclude all p reported with ns
categorised_data_final <- categorised_data_final[grep("ns", categorised_data_final$p, invert = TRUE),]

# Write out a copy 
write.csv(categorised_data_final, "2_clean_categorised.csv")

```

# Run statcheck on this data
This code came from Geoff
```{r}
# You may wish to select different data columns from a different CSV
categorised_data_final <- fread("2_clean_categorised.csv")

# Making an additional column for statistical error and gross error with NAs
categorised_data_final$error <- rep(NA, nrow(categorised_data_final))
categorised_data_final$decisionError <- rep(NA, nrow(categorised_data_final))

chosen_data_columns <- fread("2_clean_categorised.csv", select = c("statistic","df1","df2","value","reported","p"))

final_row <- 50 # You'll need to change this if you want more than 50 rows

# For now we'll just save our effect sizes in a numeric vector. Later on we may change this.
saved_effect_sizes <- vector(mode = "numeric", length = final_row) 

# Here we loop through row 1 to whatever row you've chosen as list_length
# Style guides to R will sometimes suggest to avoid loops;
# however, they're much more human-readable than the alternatives and so
# are suitable for our purposes here.
statcheck_data <- data.frame()
for(i in seq_along(categorised_data_final$PMCID)) {
  # If this code is hard to understand, you might want to try setting i <- 1 and then
  # running each line one-by-one, to see how things fit together.
  
  # In this segment we extract things we'll need for to get our Fisher-converted effect size
  test_stat_type <- chosen_data_columns$statistic[i]
  df1 <- chosen_data_columns$df1[i]
  df2 <- chosen_data_columns$df2[i]
  test_stat <- chosen_data_columns$value[i]
  p_value <- chosen_data_columns$p[i]
  
  # Before we use statcheck replace all reported statistics with P with p
  #chosen_data_columns$p <- tolower(chosen_data_columns$p)
  
  # Call Statcheck to check if the statistics have been correctly reported
  # Type ?statcheck for more information on Statcheck
  # This first call to Statcheck just tests out the "Reported" column from the CSV file
  reported_segment <- chosen_data_columns$reported[i]
  #first_statcheck <- statcheck(reported_segment)
  
  # For the second and third calls to Statcheck, instead of using the "Reported" column
  # We instead construct our own string, using different columns from the CSV file
  # It would be ideal if we'd get the same results as in the first call, but I doubt we will.
  
  if (test_stat_type == "t") {
    statcheck_type <- "t"
    # The next line should be correct. But the constructed segments for all other test types
    # are wrong
    constructed_segment <- str_c(test_stat_type,"(",df2,") = ",test_stat,", ",p_value)
  } else if (test_stat_type == "F") {
    statcheck_type <- "F"
    constructed_segment <- str_c(test_stat_type,"(",df1,",",df2,") = ",test_stat,", ",p_value)
  } else if (test_stat_type == "chi") {
    statcheck_type <- "chisq"
    constructed_segment <- str_c("chisq","(",df2,") = ",test_stat,", ",p_value)
  } else if (test_stat_type == "r") {
    statcheck_type <- "cor"
    constructed_segment <- str_c("cor","(",df2,") = ",test_stat,", ",p_value)
  } else {
    stop("end of extraction")
  }
  
  # Call Statcheck again, but using the text string we just constructed rather than the segment from the CSV file
  # I'm quite sure that will sometimes make a difference, but which is correct?
  second_statcheck <- statcheck(constructed_segment)
  print(second_statcheck)
  
  #We will replace the NAs with any error Statcheck was able to identify
  if (!is.null(second_statcheck)){
    categorised_data_final$error[i] <- second_statcheck$Error[1]
    categorised_data_final$decisionError[i] <- second_statcheck$DecisionError[1]
  } else {
    statcheck_data[i,] <- NA
  }
  
  statcheck_data <- rbind(statcheck_data, second_statcheck)
  
  # Call Statcheck again, but also specify for Statcheck the test type we think it is.
  # Will that make a difference?
  third_statcheck <- statcheck(constructed_segment,stat=statcheck_type)
  
  # At present we aren't saving anything from Statcheck - that's something you should aim to fix.
  # The code below doesn't fix that, but only displays whether a reporting error was detected.
  # The code below will need to be deleted eventually, but perhaps it will be helpful for now
  # Arbitrarily it gives data from the first call to statcheck rather than the others
  print_to_screen <- sprintf("Row %d, Test Type: %s, Reported Segment: %s, Effect Size %f, 1st Statcheck Error: %s",i,test_stat_type,reported_segment,saved_effect_sizes[i],second_statcheck$Error)

}

# write out the data with statcheck's results 
write.csv(categorised_data_final,'3_statcheck_categorised.csv')
```


